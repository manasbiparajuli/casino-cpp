//****************************************************
//* Name: Manasbi Parajuli
//* Project: Casino
//* Class: CMPS 366-01
//* Date: 10/2/2018
//****************************************************

#include "Round.h"

// ****************************************************************
// Function Name: Round
// Purpose: serves as a default constructor for Round class
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
Round::Round()
{
   roundNumber = 1;
}

// ****************************************************************
// Function Name: startGame
// Purpose: loads the deck generated by the program
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::startGame()
{
   deck.shuffleDeck();
   deck.printDeck();
   dealCardsToPlayers();
}

// ****************************************************************
// Function Name: printDeckConfigChoices
// Purpose: gives option for the user to either use deck from a file or 
//          use the deck generated by the program
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printDeckConfigChoices()
{
   cout << "******************************" << endl;
   cout << "You have the following choices to configure your deck" << endl;
   cout << "1. Use program generated deck" << endl;
   cout << "2. Use Deck saved in file" << endl;
   cout << "******************************" << endl;

   // player input for the choice
   int choice;

   cout << "Enter your choice (1/2): ";
   // validate user input
   do
   {
      cin >> choice;
   } while (!(choice == 1 || choice == 2));

   cout << endl;

   // use program generated deck
   if (choice == 1) { startGame(); }

   // load deck from file
   else { loadDeckFromFile(); }
}

// ****************************************************************
// Function Name: loadDeckFromFile
// Purpose: make a deck reading card values from a text file
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::loadDeckFromFile()
{
   // get the text file to load from the player
   string fileName;

   // a temporary vector<Card> to add Cards read from the file
   vector<Card> tempDeck;

   // flag for correct file read
   bool fileRead = true;

   do {
      fileName = "";

      // get correct text file from the user
      cout << "Enter the filename (eg. deck.txt) to load the deck: " << endl;
      getline(cin, fileName);
      
      // stream object to read from a file
      ifstream openFile(fileName.c_str());

      // check if the file was able to be read
      if (!openFile.is_open())
      {
         cerr << "\nInvalid text file read. Try Again." << endl;
         fileRead = false;
      }

      // proceed to reading contents from the file if we were able to open the file
      else
      {
         // the contents of a line from the text file
         string line;

         // the line number that the file pointer is pointing to when reading
         int lineNumber = 0;

         // suits and faces hold the combination of the card
         const vector <char> suits { 'C', 'D', 'H', 'S' };
         const vector <char> faces { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'X', 'J', 'Q', 'K' };

         // start reading from the file
         while (getline(openFile, line))
         {
            // check to make sure that the line read from the deck file is valid
            // search for the characters against the constant vector<char> of suits or faces
            // if the cards are valid, then add to the temporary vector<char> file
            // else, break from the loop 
            if ((find(suits.begin(), suits.end(), line[0]) != suits.end())
               && (find(faces.begin(), faces.end(), line[1]) != faces.end()))
            {
               tempDeck.push_back(Card("" + line[0], "" + line[1]));
               fileRead = true;
            }
            else
            {
               fileRead = false;
               cout << "Invalid card detected. Please input a valid deck file." << endl;
               break;
            }
            cout << line << endl;
         }
         //fileRead = true;
      }
      // close reading the file
      openFile.close();
   } while (fileRead == false);

   setDeck(tempDeck);
   cout << "setdeck" << endl;
}

// ****************************************************************
// Function Name: displayMainMenu
// Purpose: displays the options that the player can use in the game
//          and asks for their choices
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::displayMainMenu()
{
   // Display the choices for the user
   cout << "****************************************************\n";
   cout << "1. Save Game \n";
   cout << "2. Make a move \n";
   cout << "3. Ask for help \n";
   cout << "4. Quit Game \n";
   cout << "****************************************************\n";
   cout << "Enter Your Choice (1-4). ";

   // player input for the choices
   int choice;

   // validates the input of the player
   do {
      cin >> choice;
   } while (!(choice >= 1 && choice <= 4));

   // users will be directed based on the choices they made
   switch (choice)
   {
   case 1:
      saveGame();
      break;
   case 2:
      makeMove();
      break;
   case 3:
      getHelp();
      break;
   default:
      quitGame();
      break;
   }
}

// ****************************************************************
// Function Name: getNextPlayer
// Purpose: gets the next player in the game
// Parameters: none
// Return value: identifier of the next player, a string.
// Assistance Received: none
// ****************************************************************
string Round::getNextPlayer()
{
   return "Human";
}

// ****************************************************************
// Function Name: dealCardsToPlayer()
// Purpose: deals cards to Human, Computer and places next four cards
//          on the table
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::dealCardsToPlayers()
{
   // get 12 cards and deal to players
   for (int i = 0; i < 12; i++)
   {
      Card card = deck.dealCard();

      // Deal first four cards to the human player
      if (i < 4)
      {
         humanPlayerOne.addCardsToHand(card);
      }
      // Deal next four cards to the computer
      else if (i >= 4 && i < 8)
      {
         computerPlayerTwo.addCardsToHand(card);
      }
      // Place the next four cards on the table
      else
      {
         tableCards.push_back(card);
      }
   }
}

// ****************************************************************
// Function Name: printCardsOnHand
// Purpose: prints the current cards on the pile of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnHand()
{
   humanPlayerOne.playerCardsOnHand("Human");
   computerPlayerTwo.playerCardsOnHand("Computer");
   cardsOnTable();
}

// ****************************************************************
// Function Name: printCardsOnPile
// Purpose: prints the current cards on the hand of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnPile()
{
   humanPlayerOne.playerCardsOnPile("Human");
   computerPlayerTwo.playerCardsOnPile("Computer");
}

// ****************************************************************
// Function Name: calculateScore
// Purpose: creates Score object and calls its calculate function to 
//          calculate and then store the scores of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::calculateScore()
{
   // Create a score object by passing the cards on the pile of the players
   Score score(humanPlayerOne.getCardsOnPile(), computerPlayerTwo.getCardsOnPile());

   // calculate the score of the player using the rules of the game
   score.calculateTotalScore();

   // get the scores of both players and then set their scores by passing their scores.
   int humanScore = score.getPlayerOneScore();
   int computerScore = score.getPlayerTwoScore();

   humanPlayerOne.setPlayerScore(humanScore);
   computerPlayerTwo.setPlayerScore(computerScore);
}

// ****************************************************************
// Function Name: printScore
// Purpose: prints the scores of the players at the end of the round
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printScore()
{
   cout << "The scores at the end of the round are: " << endl;
   cout << "Human    => " << humanPlayerOne.getPlayerScore() << endl;
   cout << "Computer => " << computerPlayerTwo.getPlayerScore() << endl;
}

// ****************************************************************
// Function Name: saveGame
// Purpose: saves the current game values to a text file
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveGame()
{
   // file stream object to save contents to a file in the current directory
   ofstream saveToFile("casino.txt");

   // validates if there was any error opening the file
   // if the validation fails, the program aborts
   if (!saveToFile)
   {
      cerr << "Error opening file for output! " << endl;
      abort();
   }

   saveToFile << "Round: " << getRoundNumber();
   
   // Start saving computer's game data
   saveToFile << "Computer: " << endl;
   saveToFile << "Score: " << computerPlayerTwo.getPlayerScore() << endl;
   
   // write the contents of the cards on hand of the computer
   saveToFile << "Hand: ";
   for (auto card : computerPlayerTwo.getCardsOnHand())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // write the contents of the cards on pile of the computer
   saveToFile << "Pile: ";
   for (auto card : computerPlayerTwo.getCardsOnPile())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // Start saving human's game data
   saveToFile << "\n" << endl;
   saveToFile << "Human: " << endl;
   saveToFile << "Score: " << humanPlayerOne.getPlayerScore() << endl;

   // write the contents of the cards on hand of the human
   saveToFile << "Hand: ";
   for (auto card : humanPlayerOne.getCardsOnHand())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // write the contents of the cards on pile of the human
   saveToFile << "Pile: ";
   for (auto card : humanPlayerOne.getCardsOnPile())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   saveToFile << "\n" << endl;

   // TODO: Saving cards on the table
   saveToFile << "Table: " << endl;
   
   saveToFile << "\nBuild Owner: " << endl;

   // save the current cards on deck to the file
   saveToFile << "\nDeck: ";
   for (auto card : deck.getDeck())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   saveToFile << "Next Player: " << getNextPlayer();

   // close the output file
   saveToFile.close();

   // exit from the game after saving game data
   quitGame();
}

void Round::makeMove()
{
}

// ****************************************************************
// Function Name: getHelp
// Purpose: gets help to make moves based on a strategy for the player
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::getHelp()
{
}

// ****************************************************************
// Function Name: quitGame
// Purpose: exits from the game
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::quitGame()
{
   exit(0);
}

// ****************************************************************
// Function Name: getRoundNumber
// Purpose: gets the current round number
// Parameter: none
// Return value: the current round, an integer value
// Assistance Received: none
// ****************************************************************
int Round::getRoundNumber() const
{
   return roundNumber;
}

void Round::setDeck(vector<Card> tempDeck)
{
   deck.setDeck(tempDeck);
   deck.printDeck();
}

// ****************************************************************
// Function Name: cardsOnTable
// Purpose: prints the current cards on the table
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::cardsOnTable()
{
   cout << "Cards on table are: ";
   for (auto card : tableCards)
   {
      cout << card.cardToString() + " ";
   }
   cout << endl;
}

void Round::buildOption()
{
   humanPlayerOne.makeSingleBuild(getTableCards());
}

void Round::captureCard()
{
   string captureCard;

   cout << "Enter the card that you want to capture: ";
}

vector<Card>& Round::getTableCards()
{
   return tableCards;
}