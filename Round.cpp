//****************************************************
//* Name: Manasbi Parajuli
//* Project: Casino
//* Class: CMPS 366-01
//* Date: 10/23/2018
//****************************************************

#include "Round.h"

// ****************************************************************
// Function Name: Round
// Purpose: serves as a default constructor for Round class
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
Round::Round()
{
   roundNumber = 1;
   numberOfPlayers = 2;
   humanIndex = 0;
   computerIndex = 1;
   nextPlayer = "";
   isNewGame = true;
}

// ****************************************************************
// Function Name: Round
// Purpose: serves as a default constructor for Round class
// Parameters: -> next, a string. Holds the name of the next player
//             -> lastCap, a string. Holds the last capturer in the game
// Return value: none
// Assistance Received: none
// ****************************************************************
Round::Round(string next, string lastCap,  int rnd = 1) : 
   nextPlayer(next), 
   lastCapturer(lastCap), 
   roundNumber(rnd)
{
   numberOfPlayers = 2;
   isNewGame = false;

   // Set the index of the players based on who the next player is
   if (nextPlayer == "Human")
   {
      humanIndex = 0;
      computerIndex = 1;
   }
   if (nextPlayer == "Computer")
   {
      humanIndex = 1;
      computerIndex = 0;
   }

   if (lastCapturer == "Human")
   {
      humanIndex = 0;
      computerIndex = 1;
   }
   if (lastCapturer == "Computer")
   {
      humanIndex = 1;
      computerIndex = 0;
   }

   players[humanIndex] = new Human("Human");
   players[computerIndex] = new Computer("Computer");
}

// ****************************************************************
// Function Name: createPlayers
// Purpose: creates a pointer to two players each of human and computer and sets their index
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::createPlayers()
{
   // Set the index of the players based on who the next player is
   if (nextPlayer == "Human")
   {
      humanIndex = 0;
      computerIndex = 1;
   }
   if (nextPlayer == "Computer")
   {
      humanIndex = 1;
      computerIndex = 0;
   }
   players[humanIndex] = new Human("Human");
   players[computerIndex] = new Computer("Computer");
}

// ****************************************************************
// Function Name: startGame
// Purpose: loads the deck generated by the program
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::startGame()
{
   deck.createShuffledDeck();
   deck.printDeck();
   isNewGame = true;
}

// ****************************************************************
// Function Name: loadGame
// Purpose: loads the game from a file
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::loadGame()
{
   system("cls");
   isNewGame = false;

   // get the text file to load from the player
   string fileName;

   // flag for correct file read
   bool fileRead = true;

   do {
      // get correct text file from the user
      cout << "Enter the filename (eg. casino.txt) to load: " << endl;
      getline(cin, fileName);

      // stream object to read from a file
      ifstream openFile(fileName.c_str());

      // check if the file was able to be read
      if (!openFile.is_open())
      {
         cerr << "Invalid text file read. Try Again." << endl;
         system("cls");
         fileRead = false;
      }

      // proceed to reading contents from the file if we were able to open the file
      else
      {
         // the contents of a line from the text file
         string line;

         // the line number that the file pointer is pointing to when reading
         int lineNumber = 0;

         // create players with the correct index first when loading from the file
         while (getline(openFile, line))
         {
            lineNumber++;
            // Next Player: Human
            if (lineNumber == 21)
            {
               auto const posCol = line.find_first_of(':');
               line = line.substr(posCol + 1);

               stringstream str(line);
               string token;
               while (str >> token)
               {
                  if (token == "Human" || token == "Computer")
                  {
                     setNextPlayer(token);
                     createPlayers();
                     break;
                  }
               }
            }
         }
         openFile.close();

         // stream object to read from the file
         ifstream openFile(fileName.c_str());

         // check if the file was able to be read
         if (!openFile.is_open())
         {
            cerr << "Invalid text file read. Try Again." << endl;
            fileRead = false;
         }
         else
         {
            // reset the line number now that we proceed to setting other variables
            lineNumber = 0;
            // start reading from the file
            while (getline(openFile, line))
            {
               lineNumber++;
               setSavedPreferences(lineNumber, line);
            }
            // close reading the file
            openFile.close();

            fileRead = true;
         }
      }
   } while (fileRead == false);
}

// ****************************************************************
// Function Name: setSavedPreferences
// Purpose: sets the values from the file into the current round
// Parameters: -> lineNumber, an integer. The current linenumber that the filestream is pointing to
//             -> line, a string. The string that the current line holds
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::setSavedPreferences(int lineNumber, string line)
{
   // parsed string of the stringstream
   string token;

   stringstream str(line);

   // the card representation as string
   vector<string> cards;
   
   // Round: 3
   if (lineNumber == 1)
   {
      while (str >> token)
      {
         if (token != "Round:") { setRoundNumber(stoi(token)); }
      }
   }
   // Computer's Score: 17
   else if (lineNumber == 4)
   {
      while (str >> token)
      {
		  if (token != "Score:") { players[computerIndex]->setPlayerScore(stoi(token));}
      }
   }
   // Computer's Hand: H5 H6 D4 D7
   else if (lineNumber == 5)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Hand:") { cards.push_back(token); }
      }
      players[computerIndex]->setCardsOnHand(makeCardFromFile(cards));
   }
   // Computer's Pile: SX SQ SK D6 H8
   else if (lineNumber == 6)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Pile:") { cards.push_back(token); }
      }
      players[computerIndex]->setCardsOnPile(makeCardFromFile(cards));
   }
   // Human's Score: 14
   else if (lineNumber == 9)
   {
      while (str >> token)
      {
         if (token != "Score:") { players[humanIndex]->setPlayerScore(stoi(token)); }
      }
   }
   // Human's Hand: SA S4 CA C9
   else if (lineNumber == 10)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Hand:") { cards.push_back(token); }
      }
      players[humanIndex]->setCardsOnHand(makeCardFromFile(cards));
   }
   // Human's Pile: DJ DA C3 C5
   else if (lineNumber == 11)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Pile:") { cards.push_back(token); }
      }
      players[humanIndex]->setCardsOnPile(makeCardFromFile(cards));
   }
   // Table: [ [C6 S3] [S9] ] C8 CJ HA
   else if (lineNumber == 13)
   {
      cards = {};

	  // get the string after the last occurence of ']'
	  auto const pos = line.find_last_of(']');
	  const auto leaf = line.substr(pos + 1);

	  string cardString;
	  stringstream innerstr(leaf);

      while (innerstr >> cardString)
      {
		  // check if there are no builds in the table
		  if (cardString != "Table:")
		  {
			  cards.push_back(cardString);
		  }
      }
      setTableCards(makeCardFromFile(cards));
   }
   //Build Owner: [ [C6 S3] [S9] ] Human
   else if (lineNumber == 15)
   {
	   string token = "";
	   string owner = "";
	   int playerindex = 0;

	   stringstream str(line);

	   // Remove the Build Owner: tag from the string
	   auto const pos = line.find_first_of(':');
	   line = line.substr(pos + 1);

	   // get the single build
	   auto const posOpen = line.find_first_of('[');
	   auto const posClose = line.find_last_of(']');
	   token = line.substr(posOpen + 1, posClose - posOpen - 1);

	   stringstream str2(token);

      // push the card strings
	   while (str2 >> token)
	   {
		   cards.push_back(token);
	   }
	   
	   token = "";

	   // Get the build owner and set the player build
	   while (str >> token)
	   {
		   if (token == "Computer" || token == "Human")
		   {
			   if (token == "Computer") { owner = token; playerindex = computerIndex; }
				else if (token == "Human") { owner = token; playerindex = humanIndex; }

				tuple <string, vector<Card>> singleBld = make_tuple(owner, makeCardFromFile(cards));
				players[playerindex]->setSingleBuild(singleBld);
			}
	   }
   }
   // Last Capturer: Human
   else if (lineNumber == 17)
   {
      while (str >> token)
      {
         if (token != "Last" || token != "Capturer:") { setLastCapturer(token); }
      }
   }
   // Deck: S7 D3 D5 H2 H3 S5 D8 C2 H9 CX CQ CK HJ S2 S6 D9 DX DQ DK D2 HX HQ HK C4 C7 S8 SJ H4 H7
   else if (lineNumber == 19)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Deck:") { cards.push_back(token); }
      }
      setDeck(makeCardFromFile(cards));
   }
}

// ****************************************************************
// Function Name: makeCardFromFile
// Purpose: transforms the string of cards into vector of Card objects
// Parameters: -> cards, vector of string. The vector of strings that need to be 
//                      converted into Card objects
// Return value: vector of card objects.
// Assistance Received: none
// ****************************************************************
vector<Card> Round::makeCardFromFile(vector<string> cards)
{
   vector<Card> cardList = {};
   
   // Loop through the string and make it a card object
   // Then return cards as vector of cards
   for (auto cardStr : cards)
   {
      Card tempCard(getString(cardStr[0]), getString(cardStr[1]));
      cardList.push_back(tempCard);
   }
   return cardList;
}

// ****************************************************************
// Function Name: printDeckConfigChoices
// Purpose: gives option for the user to either use deck from a file or 
//          use the deck generated by the program
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printDeckConfigChoices()
{
   cout << "******************************" << endl;
   cout << "You have the following choices to configure your deck" << endl;
   cout << "1. Use program generated deck" << endl;
   cout << "2. Use Deck saved in file" << endl;
   cout << "******************************" << endl;

   // player input for the choice
   int choice;

   cout << "Enter your choice (1/2): ";
   // validate user input
   do
   {
      cin >> choice;
   } while (!(choice == 1 || choice == 2));

   cout << endl;

   // use program generated deck
   if (choice == 1) { startGame(); }

   // load deck from file
   else { loadDeckFromFile(); }

   cout << "******************************" << endl;
}

// ****************************************************************
// Function Name: loadDeckFromFile
// Purpose: make a deck reading card values from a text file
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::loadDeckFromFile()
{
   // get the text file to load from the player
   string fileName;

   // a temporary vector<Card> to add Cards read from the file
   vector<Card> tempDeck;

   // flag for correct file read
   bool fileRead = true;

   do {
      fileName = "";

      // get correct text file from the user
      cout << "Enter the filename (eg. deck.txt) to load the deck: " << endl;
      getline(cin, fileName);
      
      // stream object to read from a file
      ifstream openFile(fileName.c_str());

      // check if the file was able to be read
      if (!openFile.is_open())
      {
         cerr << "\nInvalid text file read. Try Again." << endl;
         fileRead = false;
      }

      // proceed to reading contents from the file if we were able to open the file
      else
      {
         // the contents of a line from the text file
         string line;

         // the line number that the file pointer is pointing to when reading
         int lineNumber = 0;

         // suits and faces hold the combination of the card
         const vector <char> suits { 'C', 'D', 'H', 'S' };
         const vector <char> faces { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'X', 'J', 'Q', 'K' };

         // start reading from the file
         while (getline(openFile, line))
         {
            // check to make sure that the line read from the deck file is valid
            // search for the characters against the constant vector<char> of suits or faces
            // if the cards are valid, then add to the temporary vector<char> file
            // else, break from the loop 
            if ((find(suits.begin(), suits.end(), line[0]) != suits.end())
               && (find(faces.begin(), faces.end(), line[1]) != faces.end()))
            {
               tempDeck.push_back(Card("" + line[0], "" + line[1]));
               fileRead = true;
            }
            else
            {
               fileRead = false;
               cout << "Invalid card detected. Please input a valid deck file." << endl;
               break;
            }
            cout << line << endl;
         }
         //fileRead = true;
      }
      // close reading the file
      openFile.close();
   } while (fileRead == false);

   setDeck(tempDeck);
}

// ****************************************************************
// Function Name: displayMainMenu
// Purpose: displays the options that the player can use in the game
//          and asks for their choices
// Parameters: turn, an integer. The current turn in the game
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::displayMainMenu(int& turn)
{
   // Display the choices for the user
   cout << "****************************************************\n";
   cout << "1. Save Game \n";
   cout << "2. Make a move \n";
   cout << "3. Ask for help \n";
   cout << "4. Quit Game \n";
   cout << "****************************************************\n";
   cout << "Enter Your Choice (1-4): ";

   // player input for the choices
   int choice;

   // validates the input of the player
   do 
   {
      cin >> choice;
   } while (!(choice >= 1 && choice <= 4));

   // users will be directed based on the choices they made
   switch (choice)
   {
   case 1:
      saveGame();
      break;
   case 2:
      makeMove(turn);
      break;
   case 3:
      getHelp(turn);
      break;
   default:
      quitGame();
      break;
   }
}

// ****************************************************************
// Function Name: dealCardsToPlayer
// Purpose: deals cards to Human, Computer and places next four cards
//          on the table
// Parameters: newRound, the boolean that holds the flag as new round
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::dealCardsToPlayers(bool newRound)
{
   int totalCardsToDeal = 0;

   if (newRound == true) { totalCardsToDeal = 12; }
   else { totalCardsToDeal = 8; }

   // get cards based on whether it is a new or ongoing round and deal accordingly
   for (int i = 0; i < totalCardsToDeal; i++)
   {
      Card card = deck.dealCard();

      // Deal first four cards to the human player
      if (i < 4)
      {
         players[humanIndex]->addCardsToHand(card);
      }
      // Deal next four cards to the computer
      else if (i >= 4 && i < 8)
      {
         players[computerIndex]->addCardsToHand(card);
      }
      // Deal cards on the table if it is a new round
      if (newRound == true)
      {
         if (i >= 8 && i < totalCardsToDeal) 
         {
            tableCards.push_back(card);
         }
      }
   }
}

// ****************************************************************
// Function Name: gamePlay
// Purpose: the logic behind the gameplay
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::gamePlay()
{
   // store the turns in the current round to alternate between players
   int turns = 0;
   int pl1Hand = 0, pl2Hand = 0;

   do
   {
      // Deal cards to players and place cards on table at the start of the first round
      if (isNewGame == true)
      {
         dealCardsToPlayers(true);
         isNewGame = false;
      }

      // store the size of the players' cards on hand
      pl1Hand = players[humanIndex]->getCardsOnHand().size();
      pl2Hand = players[computerIndex]->getCardsOnHand().size();

      // Deal cards only to players if both of their hands are empty and deck is not empty
      if (pl1Hand <= 0 && pl2Hand <= 0 && deck.isDeckEmpty() == false)
      {
         dealCardsToPlayers(false);
      }

      // Player who last captured picks up remaining cards on the table after there are no
      // cards on hand of one of the players and the deck is empty
      if ((pl1Hand == 0 && pl2Hand > 0 && deck.isDeckEmpty() == true) || (pl1Hand > 0 && pl2Hand == 0 && deck.isDeckEmpty() == true))
      {
         for (int i = 0; i < numberOfPlayers; i++)
         {
            // Add to player i's pile if lastCapturer matches its name
            if (players[i]->getPlayerName() == lastCapturer)
            {
               for (auto tableCards : getTableCards())
               {
                  players[i]->addCardsToPile(tableCards);
               }
               // After cards have been added to player's pile, remove those cards from the table
               removeCardsFromTable(getTableCards());
               break;
            }
         }
         break;
      }

      // Display ongoing cards status
      displayRoundStatus();

      // Display options for the player before every turn
      displayMainMenu(turns);

      pl1Hand = players[humanIndex]->getCardsOnHand().size();
      pl2Hand = players[computerIndex]->getCardsOnHand().size();

   } while (!(pl1Hand <= 0 && pl2Hand <= 0 && deck.isDeckEmpty() == true));
   
   // Increment the round number as we finished the deck
   roundNumber++;
}

// ****************************************************************
// Function Name: makeMove
// Purpose: alternates turns between players
// Parameter: turn, the current turn in the game
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::makeMove(int& turn)
{
   tuple<string, vector<Card>> oppoBuild;

   // get the turn values as 0 or 1
   int turnIndex = turn % numberOfPlayers;
   
   // Name player's turn
   cout << "****************************************************\n";
   cout << players[turnIndex]->getPlayerName() << "'s turn" << endl;
   cout << "****************************************************\n";

   // Handle player turns  
   // First Player turn
   if (turnIndex == 0)
   {
      // get the single build of the opponent
      oppoBuild = players[turnIndex + 1]->getSingleBuild();
    
      // let the player make a move
      players[turnIndex]->play(getTableCards(), oppoBuild);

      // set the opponent's build if their build has been modified
      players[turnIndex + 1]->setSingleBuild(oppoBuild);

      // set the last capturer to this player if any capturing of cards was done in this move
      if (players[turnIndex]->hasCapturedCard() == true)
      {
         lastCapturer = players[turnIndex]->getPlayerName();
      }
      // increment the turn
      turn++;
   }
   // Second Player's turn
   else if (turnIndex == 1)
   {
      // get the single build of the opponent
      oppoBuild = players[turnIndex - 1]->getSingleBuild();

      // let the player make a move
      players[turnIndex]->play(getTableCards(), oppoBuild);

      // set the opponent's build if their build has been modified
      players[turnIndex - 1]->setSingleBuild(oppoBuild);

      // set the last capturer to this player if any capturing of cards was done in this move
      if (players[turnIndex]->hasCapturedCard() == true)
      {
         lastCapturer = players[turnIndex]->getPlayerName();
      }
      // increment the turn
      turn++;
   }
}

// ****************************************************************
// Function Name: calculateScore
// Purpose: creates Score object and calls its calculate function to 
//          calculate and then store the scores of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::calculateScore()
{
   // Create a score object by passing the cards on the pile of the players
   Score score(players[humanIndex]->getCardsOnPile(), players[computerIndex]->getCardsOnPile());

   // calculate the score of the player using the rules of the game
   score.calculateTotalScore();

   // get the scores of both players and then set their scores by passing their scores.
   int humanScore = score.getPlayerOneScore() + players[humanIndex]->getPlayerScore();
   int computerScore = score.getPlayerTwoScore() + players[computerIndex]->getPlayerScore();

   players[humanIndex]->setPlayerScore(humanScore);
   players[computerIndex]->setPlayerScore(computerScore);
}

// ****************************************************************
// Function Name: sendRndScoreToTourney
// Purpose: returns the pair of players' score and their round scores to the tournament
// Parameter: none
// Return value: a vector of pair of string and int that refer to player's names and their scores respectively
// Assistance Received: none
// ****************************************************************
vector<pair<string, int>> Round::sendRndScoreToTourney()
{
   vector<pair<string, int>> scores = {};

   // return the players' name and score as pair
   for (int i = 0; i < numberOfPlayers; i++)
   {
      scores.push_back(make_pair(players[i]->getPlayerName(), players[i]->getPlayerScore()));
   }
   return scores;
}

// ****************************************************************
// Function Name: printScore
// Purpose: prints the scores of the players at the end of the round
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printScore()
{
   cout << "*************************************************" << endl;
   cout << "The scores at the end of the round are: " << endl;

   for (int i = 0; i < numberOfPlayers; i++)
   {
      cout << players[i]->getPlayerName() << "=> " << players[i]->getPlayerScore() << endl;
   }
}

// ****************************************************************
// Function Name: saveGame
// Purpose: saves the current game values to a text file
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveGame()
{
   // file stream object to save contents to a file in the current directory
   ofstream saveToFile("casinosave.txt");

   // validates if there was any error opening the file
   // if the validation fails, the program aborts
   if (!saveToFile)
   {
      cerr << "Error opening file for output! " << endl;
      abort();
   }

   saveToFile << "Round: " << getRoundNumber() << endl;
   
   // Start saving computer's game data
   saveToFile << endl;
   saveToFile << "Computer: " << endl;
   saveToFile << "Score: " << players[computerIndex]->getPlayerScore() << endl;
   
   // write the contents of the cards on hand of the computer
   saveToFile << "Hand: ";
   for (auto card : players[computerIndex]->getCardsOnHand())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // write the contents of the cards on pile of the computer
   saveToFile << "Pile: ";
   for (auto card : players[computerIndex]->getCardsOnPile())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // Start saving human's game data
   saveToFile << endl;
   saveToFile << "Human: " << endl;
   saveToFile << "Score: " << players[humanIndex]->getPlayerScore() << endl;

   // write the contents of the cards on hand of the human
   saveToFile << "Hand: ";
   for (auto card : players[humanIndex]->getCardsOnHand())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // write the contents of the cards on pile of the human
   saveToFile << "Pile: ";
   for (auto card : players[humanIndex]->getCardsOnPile())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;
   saveToFile << endl;

   saveToFile << "Table: ";   
   saveTableCardsToFile(saveToFile);

   saveToFile << endl;
   saveToFile << endl;
   saveToFile << "Build Owner: " << endl;
   saveBuildOwnerToFile(saveToFile);

   // save the last capturer
   saveToFile << endl;
   saveToFile << "Last Capturer: " << getLastCapturer() << endl;

   // save the current cards on deck to the file
   saveToFile << endl;
   saveToFile << "Deck: ";
   for (auto card : deck.getDeck())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   saveToFile << endl;
   saveToFile << "Next Player: " << getNextPlayer();

   // close the output file
   saveToFile.close();

   // exit from the game after saving game data
   quitGame();
}

// ****************************************************************
// Function Name: saveBuildOwnerToFile
// Purpose: saves the build owner to file
// Parameter: saveToFile -> ofstream object. Holds the file stream for saving to file
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveBuildOwnerToFile(ofstream &saveToFile)
{
   vector<vector<Card>> multiBuild;
   vector<Card> singleBuild;

   // Save multiple builds to file if any exists
   if (players[humanIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[humanIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
      saveToFile << players[humanIndex]->getPlayerName();
   }
   if (players[computerIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[computerIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
      saveToFile << players[computerIndex]->getPlayerName();
   }

   // Save single builds to file if any exists
   if (players[humanIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[humanIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
      saveToFile << players[humanIndex]->getPlayerName();
   }
   if (players[computerIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[computerIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
      saveToFile << players[computerIndex]->getPlayerName();
   }
}

// ****************************************************************
// Function Name: saveTableCardsToFile
// Purpose: saves the player's single and multiple builds and then the ongoing table cards to file
// Parameter: saveToFile -> ofstream object. Holds the file stream for saving to file
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveTableCardsToFile(ofstream &saveToFile)
{
   vector<vector<Card>> multiBuild;
   vector<Card> singleBuild;

   // Save multiple builds to file if any exists
   if (players[humanIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[humanIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
   }
   if (players[computerIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[computerIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
   }

   // Save single builds to file if any exists
   if (players[humanIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[humanIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
   }
   if (players[computerIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[computerIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
   }

   // save table cards after saving builds to file
   for (auto tableCards : getTableCards())
   {
      saveToFile << tableCards.cardToString() << " ";
   }
   cout << endl;
}

// ****************************************************************
// Function Name: saveSingleBuildToFile
// Purpose: saves the player's single build to a text file
// Parameter: saveToFile -> ofstream object. Holds the file stream for saving to file
//            multiBuild -> vector of Cards. Holds the player's single to be saved to a file 
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveSingleBuildToFile(ofstream &saveToFile, vector<Card> &singleBuild)
{
   saveToFile << "[";
   for (auto cards : singleBuild)
   {
      saveToFile << cards.cardToString() << " ";
   }
   saveToFile << "]";
}

// ****************************************************************
// Function Name: saveMultipleBuildToFile
// Purpose: saves the player's multiple build to a text file
// Parameter: saveToFile -> ofstream object. Holds the file stream for saving to file
//            multiBuild -> vector of vector of Cards. Holds the player's multibuild to be saved to a file 
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveMultipleBuildToFile(std::ofstream &saveToFile, vector<vector<Card>> &multiBuild)
{
   saveToFile << "[ ";

   for (auto parseBuild : multiBuild)
   {
      saveToFile << "[";
      for (auto cards : parseBuild)
      {
         saveToFile << cards.cardToString() << " ";
      }
      saveToFile << "]";
   }
   saveToFile << "]";
}

// ****************************************************************
// Function Name: getHelp
// Purpose: gets help to make moves based on a strategy for the human players
// Parameter: turn-> holds the current turn in the round
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::getHelp(int & turn)
{
   int turnIndex = turn % numberOfPlayers;

   if (players[turnIndex]->getPlayerName() == "Computer")
   {
      cout << "Invalid. Computer cannot get help function!!" << endl;
   }
}

// ****************************************************************
// Function Name: quitGame
// Purpose: exits from the game
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::quitGame()
{
   exit(0);
}

// ****************************************************************
// Function Name: getRoundNumber
// Purpose: gets the current round number
// Parameter: none
// Return value: the current round, an integer value
// Assistance Received: none
// ****************************************************************
int Round::getRoundNumber() const
{
   return roundNumber;
}

// ****************************************************************
// Function Name: setRoundNumber
// Purpose: sets the current round number
// Parameter: rnd, an integer value. Holds the new round number
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::setRoundNumber(int rnd)
{
   roundNumber = rnd;
}

// ****************************************************************
// Function Name: getLastCapturer
// Purpose: gets the last capturer player in the game
// Parameters: none
// Return value: identifier of the last capturer player, a string.
// Assistance Received: none
// ****************************************************************
string Round::getLastCapturer() const
{
   return lastCapturer;
}

// ****************************************************************
// Function Name: setLastCapturer
// Purpose: sets the last capturer in the game
// Parameters: capturer, a string. Holds the name of the last capturer in the game
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::setLastCapturer(string capturer)
{
   lastCapturer = capturer;
}

// ****************************************************************
// Function Name: getNextPlayer
// Purpose: gets the next player in the game
// Parameters: none
// Return value: identifier of the next player, a string.
// Assistance Received: none
// ****************************************************************
string Round::getNextPlayer() const
{
   return nextPlayer;
}

// ****************************************************************
// Function Name: setNextPlayer
// Purpose: sets the next player in the game
// Parameters: next, a string. Holds the name of the next player in the game
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::setNextPlayer(string next)
{
   nextPlayer = next;
}

// ****************************************************************
// Function Name: setDeck
// Purpose: sets the deck in the game
// Parameters: tempDeck, a vector of cards. Hold the new deck for the game
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::setDeck(vector<Card> tempDeck)
{
   deck.setDeck(tempDeck);
}

// ****************************************************************
// Function Name: getTableCards
// Purpose: gets the current cards in the table
// Parameters: none
// Return value: a vector of table cards.
// Assistance Received: none
// ****************************************************************
vector<Card>& Round::getTableCards()
{
   return tableCards;
}

// ****************************************************************
// Function Name: setTableCards
// Purpose: sets the current cards in the table
// Parameters: cards, a vector of table cards
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::setTableCards(vector<Card> cards)
{
   tableCards = cards;
}

// ****************************************************************
// Function Name: getString
// Purpose: converts a character into a string
// Parameters: x, a character. Holds any character that needs conversion to string
// Return value: the string representation of the character
// Assistance Received: none
// ****************************************************************
string Round::getString(char x)
{
   string temp(1, x);
   return temp;
}

// ****************************************************************
// Function Name: isTableEmpty
// Purpose: checks if the table is empty or not
// Parameters: none
// Return value: returns true or false based on whether the table is empty or not
// Assistance Received: none
// ****************************************************************
bool Round::isTableEmpty() const
{
   return tableCards.empty();
}

// ****************************************************************
// Function Name: removeCardFromTable
// Purpose: remove the group of cards from table
// Parameters: cardsToRemove, a vector of cards that need to be 
//                   removed from the table
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::removeCardsFromTable(vector<Card> cardsToRemove)
{
   for (auto builtCards : cardsToRemove)
   {
      tableCards.erase(remove(tableCards.begin(), tableCards.end(), builtCards), tableCards.end());
   }
}

// ****************************************************************
// Function Name: displayRoundStatus
// Purpose: prints the cards held by the players and on their pile. 
//          also, prints the deck and the cards on the table
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::displayRoundStatus()
{   
   cout << "**********************************" << endl;
   cout << "Deck: ";
   deck.printDeck();
   cout << "**********************************" << endl;
   printCardsOnTable();
   cout << "**********************************" << endl;
   printCardsOnHand();
   cout << "**********************************" << endl;
   printCardsOnPile();
   cout << "**********************************" << endl;
}

// ****************************************************************
// Function Name: cardsOnTable
// Purpose: prints the current cards on the table
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnTable()
{
   cout << "Cards on table are: ";

   // Print the builds of the players first
   for (int i = 0; i < numberOfPlayers; i++)
   {
      players[i]->printMultipleBuild();
      players[i]->printSingleBuild();
   }

   // Print the tablecards
   for (auto card : tableCards)
   {
      cout << card.cardToString() + " ";
   }
   cout << endl;
}

// ****************************************************************
// Function Name: printCardsOnHand
// Purpose: prints the current cards on the hand of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnHand()
{
   for (int i = 0; i < numberOfPlayers; i++)
   {
      players[i]->printCardsOnHand();
   }
}

// ****************************************************************
// Function Name: printCardsOnPile
// Purpose: prints the current cards on the pile of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnPile()
{
   for (int i = 0; i < numberOfPlayers; i++)
   {
      players[i]->printCardsOnPile();
   }
}

// ****************************************************************
// Function Name: ~Round
// Purpose: destructor for Round class 
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
Round::~Round()
{
}