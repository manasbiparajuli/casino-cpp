//****************************************************
//* Name: Manasbi Parajuli
//* Project: Casino
//* Class: CMPS 366-01
//* Date: 10/23/2018
//****************************************************

#include "Round.h"

// ****************************************************************
// Function Name: Round
// Purpose: serves as a default constructor for Round class
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
Round::Round(string next, string lastCap,  int rnd = 1) : 
   nextPlayer(next), 
   lastCapturer(lastCap), 
   roundNumber(rnd)
{
   numberOfPlayers = 2;
   isNewGame = false;

   createPlayers();
}

void Round::createPlayers()
{
   if (nextPlayer == "Human")
   {
      humanIndex = 0;
      computerIndex = 1;
   }
   if (nextPlayer == "Computer")
   {
      humanIndex = 1;
      computerIndex = 0;
   }

   players[humanIndex] = new Human("Human");
   players[computerIndex] = new Computer("Computer");
}

// ****************************************************************
// Function Name: startGame
// Purpose: loads the deck generated by the program
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::startGame()
{
   deck.createShuffledDeck();
   deck.printDeck();
   isNewGame = true;
}

void Round::loadGame()
{
   // get the text file to load from the player
   string fileName = " ";

   // flag for correct file read
   bool fileRead = true;

   do {
      // get correct text file from the user
      cout << "Enter the filename (eg. casino.txt) to load: " << endl;
      getline(cin, fileName);

      // stream object to read from a file
      ifstream openFile(fileName.c_str());

      // check if the file was able to be read
      if (!openFile.is_open())
      {
         cerr << "Invalid text file read. Try Again." << endl;
         fileRead = false;
      }

      // proceed to reading contents from the file if we were able to open the file
      else
      {
         // the contents of a line from the text file
         string line;

         // the line number that the file pointer is pointing to when reading
         int lineNumber = 0;

         // start reading from the file
         while (getline(openFile, line))
         {
            lineNumber++;
            setSavedPreferences(lineNumber, line);
         }

         // close reading the file
         openFile.close();

         fileRead = true;
      }
   } while (fileRead == false);
}

void Round::setSavedPreferences(int lineNumber, string line)
{
   string token;
   int wordCount = 0;
   stringstream str(line);
   vector<string> cards;
   
   // Round: 3
   if (lineNumber == 1)
   {
      while (str >> token)
      {
         if (token != "Round:") { setRoundNumber(stoi(token)); }
      }
   }
   // Computer's Score: 17
   else if (lineNumber == 4)
   {
      while (str >> token)
      {
         if (token != "Score:") { players[computerIndex]->setPlayerScore(stoi(token)); }
      }
   }
   // Computer's Hand: H5 H6 D4 D7
   else if (lineNumber == 5)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Hand:") { cards.push_back(token); }
      }
      players[computerIndex]->setCardsOnHand(makeCardFromFile(cards));
   }
   // Computer's Pile: SX SQ SK D6 H8
   else if (lineNumber == 6)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Pile:") { cards.push_back(token); }
      }
      players[computerIndex]->setCardsOnPile(makeCardFromFile(cards));
   }
   // Human's Score: 14
   else if (lineNumber == 9)
   {
      while (str >> token)
      {
         if (token != "Score:") { players[humanIndex]->setPlayerScore(stoi(token)); }
      }
   }
   // Human's Hand: SA S4 CA C9
   else if (lineNumber == 10)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Hand:") { cards.push_back(token); }
      }
      players[humanIndex]->setCardsOnHand(makeCardFromFile(cards));
   }
   // Human's Pile: DJ DA C3 C5
   else if (lineNumber == 11)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Pile:") { cards.push_back(token); }
      }
      players[humanIndex]->setCardsOnPile(makeCardFromFile(cards));
   }
   // Table: [ [C6 S3] [S9] ] C8 CJ HA
   else if (lineNumber == 13)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Table:")
         {
            cards.push_back(token);
         }
      }
      setTableCards(makeCardFromFile(cards));
   }
   //Build Owner: [ [C6 S3] [S9] ] Human
   else if (lineNumber == 15)
   {

   }
   // Last Capturer: Human
   else if (lineNumber == 17)
   {
      while (str >> token)
      {
         if (token != "Last" || token != "Capturer:") { setLastCapturer(token); }
      }
   }
   // Deck: S7 D3 D5 H2 H3 S5 D8 C2 H9 CX CQ CK HJ S2 S6 D9 DX DQ DK D2 HX HQ HK C4 C7 S8 SJ H4 H7
   else if (lineNumber == 19)
   {
      cards = {};
      while (str >> token)
      {
         if (token != "Deck:") { cards.push_back(token); }
      }
      setDeck(makeCardFromFile(cards));
   }
   // Next Player: Human
   else if (lineNumber == 21)
   {
      while (str >> token)
      {
         if (token != "Next" || token != "Player:") 
         { 
            setNextPlayer(token); 
            createPlayers();
         }
      }
   }
}

vector<Card> Round::makeCardFromFile(vector<string> cards)
{
   vector<Card> cardList = {};
   
   // Loop through the string and make it a card object
   // Then return cards as vector of cards
   for (auto cardStr : cards)
   {
      Card tempCard(getString(cardStr[0]), getString(cardStr[1]));
      cardList.push_back(tempCard);
   }
   return cardList;
}

// ****************************************************************
// Function Name: printDeckConfigChoices
// Purpose: gives option for the user to either use deck from a file or 
//          use the deck generated by the program
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printDeckConfigChoices()
{
   cout << "******************************" << endl;
   cout << "You have the following choices to configure your deck" << endl;
   cout << "1. Use program generated deck" << endl;
   cout << "2. Use Deck saved in file" << endl;
   cout << "******************************" << endl;

   // player input for the choice
   int choice;

   cout << "Enter your choice (1/2): ";
   // validate user input
   do
   {
      cin >> choice;
   } while (!(choice == 1 || choice == 2));

   cout << endl;

   // use program generated deck
   if (choice == 1) { startGame(); }

   // load deck from file
   else { loadDeckFromFile(); }
}

// ****************************************************************
// Function Name: loadDeckFromFile
// Purpose: make a deck reading card values from a text file
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::loadDeckFromFile()
{
   // get the text file to load from the player
   string fileName;

   // a temporary vector<Card> to add Cards read from the file
   vector<Card> tempDeck;

   // flag for correct file read
   bool fileRead = true;

   do {
      fileName = "";

      // get correct text file from the user
      cout << "Enter the filename (eg. deck.txt) to load the deck: " << endl;
      getline(cin, fileName);
      
      // stream object to read from a file
      ifstream openFile(fileName.c_str());

      // check if the file was able to be read
      if (!openFile.is_open())
      {
         cerr << "\nInvalid text file read. Try Again." << endl;
         fileRead = false;
      }

      // proceed to reading contents from the file if we were able to open the file
      else
      {
         // the contents of a line from the text file
         string line;

         // the line number that the file pointer is pointing to when reading
         int lineNumber = 0;

         // suits and faces hold the combination of the card
         const vector <char> suits { 'C', 'D', 'H', 'S' };
         const vector <char> faces { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'X', 'J', 'Q', 'K' };

         // start reading from the file
         while (getline(openFile, line))
         {
            // check to make sure that the line read from the deck file is valid
            // search for the characters against the constant vector<char> of suits or faces
            // if the cards are valid, then add to the temporary vector<char> file
            // else, break from the loop 
            if ((find(suits.begin(), suits.end(), line[0]) != suits.end())
               && (find(faces.begin(), faces.end(), line[1]) != faces.end()))
            {
               tempDeck.push_back(Card("" + line[0], "" + line[1]));
               fileRead = true;
            }
            else
            {
               fileRead = false;
               cout << "Invalid card detected. Please input a valid deck file." << endl;
               break;
            }
            cout << line << endl;
         }
         //fileRead = true;
      }
      // close reading the file
      openFile.close();
   } while (fileRead == false);

   setDeck(tempDeck);
   cout << "setdeck" << endl;
}

// ****************************************************************
// Function Name: displayMainMenu
// Purpose: displays the options that the player can use in the game
//          and asks for their choices
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::displayMainMenu(int& turn)
{
   // Display the choices for the user
   cout << "****************************************************\n";
   cout << "1. Save Game \n";
   cout << "2. Make a move \n";
   cout << "3. Ask for help \n";
   cout << "4. Quit Game \n";
   cout << "****************************************************\n";
   cout << "Enter Your Choice (1-4). ";

   // player input for the choices
   int choice;

   // validates the input of the player
   do 
   {
      cin >> choice;
   } while (!(choice >= 1 && choice <= 4));

   // users will be directed based on the choices they made
   switch (choice)
   {
   case 1:
      saveGame();
      break;
   case 2:
      makeMove(turn);
      break;
   case 3:
      getHelp(turn);
      break;
   default:
      quitGame();
      break;
   }
}

// ****************************************************************
// Function Name: dealCardsToPlayer()
// Purpose: deals cards to Human, Computer and places next four cards
//          on the table
// Parameters: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::dealCardsToPlayers(bool newRound)
{
   int totalCardsToDeal = 0;

   if (newRound == true) { totalCardsToDeal = 12; }
   else { totalCardsToDeal = 8; }

   // get cards based on whether it is a new or ongoing round and deal
   for (int i = 0; i < totalCardsToDeal; i++)
   {
      Card card = deck.dealCard();

      // Deal first four cards to the human player
      if (i < 4)
      {
         players[humanIndex]->addCardsToHand(card);
      }
      // Deal next four cards to the computer
      else if (i >= 4 && i < 8)
      {
         players[computerIndex]->addCardsToHand(card);
      }

      // Deal cards on the table if it is a new round
      if (newRound == true)
      {
         if (i >= 8 && i < totalCardsToDeal) 
         {
            tableCards.push_back(card);
         }
      }
   }
}

void Round::gamePlay()
{
   // store the turns in the current round to alternate between players
   int turns = 0;
   
   do
   {
      // store the size of the players' cards on hand
      int pl1Hand = players[humanIndex]->getCardsOnHand().size();
      int pl2Hand = players[computerIndex]->getCardsOnHand().size();

      // Deal cards to players and place cards on table at the start of the first round
      if (isNewGame == true)
      {
         dealCardsToPlayers(true);
         isNewGame = false;
      }

      // Deal cards only to players if both of their hands are empty and deck is not empty
      if (pl1Hand <= 0 && pl2Hand <= 0 && deck.isDeckEmpty() == false)
      {
         dealCardsToPlayers(false);
      }

      // Player who last captured picks up remaining cards on the table after there are no
      // cards on hand of both the players and the deck is empty
      if (pl1Hand <= 0 && pl2Hand <= 0 && deck.isDeckEmpty() == true)
      {
         for (int i = 0; i < numberOfPlayers; i++)
         {
            // Add to player i's pile if lastCapturer matches its name
            if (players[i]->getPlayerName() == lastCapturer)
            {
               for (auto tableCards : getTableCards())
               {
                  players[i]->addCardsToPile(tableCards);
               }
               // After cards have been added to player's pile, remove those cards from the table
               removeCardsFromTable(getTableCards());
               break;
            }
         }
         break;
      }

      // Display ongoing cards status
      displayRoundStatus();

      // Display options for the player before every turn
      displayMainMenu(turns);

   } while (deck.isDeckEmpty() == false);
   
   // Increment the round number as we finished the deck
   roundNumber++;
}

void Round::makeMove(int& turn)
{
   tuple<string, vector<Card>> oppoBuild;

   int turnIndex = turn % numberOfPlayers;

   // Handle player turns  
   // First Player turn
   if (turnIndex == 0)
   {
      // get the single build of the opponent
      oppoBuild = players[turnIndex + 1]->getSingleBuild();
    
      // let the player make a move
      players[turnIndex]->play(getTableCards(), oppoBuild);

      // set the opponent's build if their build has been modified
      players[turnIndex + 1]->setSingleBuild(oppoBuild);

      // set the last capturer to this player if any capturing of cards was done in this move
      if (players[turnIndex]->hasCapturedCard() == true)
      {
         lastCapturer = players[turnIndex]->getPlayerName();
      }

      // increment the turn
      turn++;
   }
   // Second Player's turn
   else if (turnIndex == 1)
   {
      // get the single build of the opponent
      oppoBuild = players[turnIndex - 1]->getSingleBuild();

      // let the player make a move
      players[turnIndex]->play(getTableCards(), oppoBuild);

      // set the opponent's build if their build has been modified
      players[turnIndex - 1]->setSingleBuild(oppoBuild);

      // set the last capturer to this player if any capturing of cards was done in this move
      if (players[turnIndex]->hasCapturedCard() == true)
      {
         lastCapturer = players[turnIndex]->getPlayerName();
      }

      // increment the turn
      turn++;
   }
}

// ****************************************************************
// Function Name: calculateScore
// Purpose: creates Score object and calls its calculate function to 
//          calculate and then store the scores of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::calculateScore()
{
   // Create a score object by passing the cards on the pile of the players
   Score score(players[humanIndex]->getCardsOnPile(), players[computerIndex]->getCardsOnPile());

   // calculate the score of the player using the rules of the game
   score.calculateTotalScore();

   // get the scores of both players and then set their scores by passing their scores.
   int humanScore = score.getPlayerOneScore();
   int computerScore = score.getPlayerTwoScore();

   players[humanIndex]->setPlayerScore(humanScore);
   players[computerIndex]->setPlayerScore(computerScore);
}

vector<pair<string, int>> Round::sendRndScoreToTourney()
{
   vector<pair<string, int>> scores = {};

   // return the players' name and score as pair
   for (int i = 0; i < numberOfPlayers; i++)
   {
      scores.push_back(make_pair(players[i]->getPlayerName(), players[i]->getPlayerScore()));
   }
   return scores;
}

// ****************************************************************
// Function Name: printScore
// Purpose: prints the scores of the players at the end of the round
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printScore()
{
   cout << "The scores at the end of the round are: " << endl;

   for (int i = 0; i < numberOfPlayers; i++)
   {
      cout << players[i]->getPlayerName() << "=> " << players[i]->getPlayerScore() << endl;
   }
}

// ****************************************************************
// Function Name: saveGame
// Purpose: saves the current game values to a text file
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::saveGame()
{
   // file stream object to save contents to a file in the current directory
   ofstream saveToFile("casinosave.txt");

   // validates if there was any error opening the file
   // if the validation fails, the program aborts
   if (!saveToFile)
   {
      cerr << "Error opening file for output! " << endl;
      abort();
   }

   saveToFile << "Round: " << getRoundNumber();
   
   // Start saving computer's game data
   saveToFile << "Computer: " << endl;
   saveToFile << "Score: " << players[computerIndex]->getPlayerScore() << endl;
   
   // write the contents of the cards on hand of the computer
   saveToFile << "Hand: ";
   for (auto card : players[computerIndex]->getCardsOnHand())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // write the contents of the cards on pile of the computer
   saveToFile << "Pile: ";
   for (auto card : players[computerIndex]->getCardsOnPile())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // Start saving human's game data
   saveToFile << "\n" << endl;
   saveToFile << "Human: " << endl;
   saveToFile << "Score: " << players[humanIndex]->getPlayerScore() << endl;

   // write the contents of the cards on hand of the human
   saveToFile << "Hand: ";
   for (auto card : players[humanIndex]->getCardsOnHand())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   // write the contents of the cards on pile of the human
   saveToFile << "Pile: ";
   for (auto card : players[humanIndex]->getCardsOnPile())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;
   saveToFile << "\n" << endl;

   saveToFile << "Table: ";   
   saveTableCardsToFile(saveToFile);

   saveToFile << "\nBuild Owner: " << endl;
   saveBuildOwnerToFile(saveToFile);

   // save the current cards on deck to the file
   saveToFile << "\nDeck: ";
   for (auto card : deck.getDeck())
   {
      saveToFile << card.cardToString() << " ";
   }
   saveToFile << endl;

   saveToFile << "Next Player: " << getNextPlayer();

   // close the output file
   saveToFile.close();

   // exit from the game after saving game data
   quitGame();
}

void Round::saveBuildOwnerToFile(ofstream &saveToFile)
{
   vector<vector<Card>> multiBuild;
   vector<Card> singleBuild;

   // Save multiple builds to file if any exists
   if (players[humanIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[humanIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
      saveToFile << players[humanIndex]->getPlayerName();
   }
   if (players[computerIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[computerIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
      saveToFile << players[computerIndex]->getPlayerName();
   }

   // Save single builds to file if any exists
   if (players[humanIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[humanIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
      saveToFile << players[humanIndex]->getPlayerName();
   }

   if (players[computerIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[computerIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
      saveToFile << players[computerIndex]->getPlayerName();
   }
}

void Round::saveTableCardsToFile(ofstream &saveToFile)
{
   vector<vector<Card>> multiBuild;
   vector<Card> singleBuild;

   // Save multiple builds to file if any exists
   if (players[humanIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[humanIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
   }
   if (players[computerIndex]->isMultipleBuildExist() == true)
   {
      tie(ignore, multiBuild) = players[computerIndex]->getMultipleBuild();
      saveMultipleBuildToFile(saveToFile, multiBuild);
   }

   // Save single builds to file if any exists
   if (players[humanIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[humanIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
   }

   if (players[computerIndex]->isSingleBuildExist() == true)
   {
      tie(ignore, singleBuild) = players[computerIndex]->getSingleBuild();
      saveSingleBuildToFile(saveToFile, singleBuild);
   }

   for (auto tableCards : getTableCards())
   {
      saveToFile << tableCards.cardToString() << " ";
   }
   cout << endl;
}

void Round::saveSingleBuildToFile(ofstream &saveToFile, vector<Card> &singleBuild)
{
   saveToFile << "[";
   for (auto cards : singleBuild)
   {
      saveToFile << cards.cardToString() << " ";
   }
   saveToFile << "]";
}

void Round::saveMultipleBuildToFile(std::ofstream &saveToFile, vector<vector<Card>> &multiBuild)
{
   saveToFile << "[ ";

   for (auto parseBuild : multiBuild)
   {
      saveToFile << "[";
      for (auto cards : parseBuild)
      {
         saveToFile << cards.cardToString() << " ";
      }
      saveToFile << "]";
   }
   saveToFile << "]";
}

// ****************************************************************
// Function Name: getHelp
// Purpose: gets help to make moves based on a strategy for the player
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::getHelp(int & turn)
{
}

// ****************************************************************
// Function Name: quitGame
// Purpose: exits from the game
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::quitGame()
{
   exit(0);
}

// ****************************************************************
// Function Name: getRoundNumber
// Purpose: gets the current round number
// Parameter: none
// Return value: the current round, an integer value
// Assistance Received: none
// ****************************************************************
int Round::getRoundNumber() const
{
   return roundNumber;
}

void Round::setRoundNumber(int rnd)
{
   roundNumber = rnd;
}

string Round::getLastCapturer() const
{
   return lastCapturer;
}

void Round::setLastCapturer(string capturer)
{
   lastCapturer = capturer;
}

// ****************************************************************
// Function Name: getNextPlayer
// Purpose: gets the next player in the game
// Parameters: none
// Return value: identifier of the next player, a string.
// Assistance Received: none
// ****************************************************************
string Round::getNextPlayer() const
{
   return nextPlayer;
}

void Round::setNextPlayer(string next)
{
   nextPlayer = next;
}

void Round::setDeck(vector<Card> tempDeck)
{
   deck.setDeck(tempDeck);
   deck.printDeck();
}


vector<Card>& Round::getTableCards()
{
   return tableCards;
}

void Round::setTableCards(vector<Card> cards)
{
   tableCards = cards;
}

string Round::getString(char x)
{
   string temp(1, x);
   return temp;
}

bool Round::isTableEmpty() const
{
   return tableCards.empty();
}

void Round::removeCardsFromTable(vector<Card> cardsToRemove)
{
   for (auto builtCards : cardsToRemove)
   {
      tableCards.erase(remove(tableCards.begin(), tableCards.end(), builtCards), tableCards.end());
   }
}

void Round::displayRoundStatus()
{
   cout << "**********************************" << endl;
   cout << "**********************************" << endl;
   printCardsOnTable();
   cout << "**********************************" << endl;
   printCardsOnHand();
   cout << "**********************************" << endl;
   printCardsOnPile();
   cout << "**********************************" << endl;
   cout << "**********************************" << endl;
}

// ****************************************************************
// Function Name: cardsOnTable
// Purpose: prints the current cards on the table
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnTable()
{
   cout << "Cards on table are: ";

   // Print the builds of the players first
   for (int i = 0; i < numberOfPlayers; i++)
   {
      players[i]->printMultipleBuild();
      players[i]->printSingleBuild();
   }

   // Print the tablecards
   for (auto card : tableCards)
   {
      cout << card.cardToString() + " ";
   }
   cout << endl;
}

// ****************************************************************
// Function Name: printCardsOnHand
// Purpose: prints the current cards on the hand of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnHand()
{
   for (int i = 0; i < numberOfPlayers; i++)
   {
      players[i]->printCardsOnHand();
   }
}

// ****************************************************************
// Function Name: printCardsOnPile
// Purpose: prints the current cards on the pile of human and computer
// Parameter: none
// Return value: none
// Assistance Received: none
// ****************************************************************
void Round::printCardsOnPile()
{
   for (int i = 0; i < numberOfPlayers; i++)
   {
      players[i]->printCardsOnPile();
   }
}

Round::~Round()
{
}
